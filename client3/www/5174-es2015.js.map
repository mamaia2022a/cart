{"version":3,"sources":["webpack:///node_modules/@ionic/core/dist/esm/ion-route_4.entry.js"],"names":["Route","hostRef","r","this","ionRouteDataChanged","url","newValue","emit","oldValue","keys1","Object","keys","keys2","length","key","onUpdate","RouteRedirect","ionRouteRedirectChanged","generatePath","segments","filter","s","join","parsePath","path","split","map","trim","writeNavState","async","root","chain","direction","index","changed","animation","outlet","searchNavNode","Promise","resolve","c","route","result","setRouteId","id","params","element","markVisible","e","console","error","QUERY","matches","querySelector","undefined","routeRedirect","routes","find","input","from","to","i","expected","matchesIDs","ids","len","Math","min","toLowerCase","matchesPath","inputPath","RouterSegments","allparams","matchesDefault","segment","data","next","slice","mergeParams","beforeEnter","beforeLeave","a","b","assign","routerPathToChain","chains","match","matchedChain","score","computePriority","level","pow","shift","readRedirects","Array","children","el","tagName","readProp","readRoutes","flattenRouterTree","readRouteNodes","node","component","Error","componentProps","prop","hasAttribute","getAttribute","nodes","flattenNode","push","sub","Router","ionRouteWillChange","ionRouteDidChange","previousPath","busy","state","lastState","useHash","debug","document","body","window","addEventListener","once","onRoutesChanged","onRedirectChanged","bind","historyDirection","getPath","canProceed","runGuards","redirect","writeNavStateRoot","ev","detail","register","processNextHandler","back","startsWith","URL","location","href","pathname","queryString","setPath","history","waitPromise","group","forEach","groupEnd","redirects","warn","getRouteId","maxMatches","plainIDs","param","safeWriteNavState","win","replaceState","title","redirectFrom","unlock","lock","p","toChain","fromChain","beforeEnterHook","beforeLeaveHook","canLeave","canEnter","routeEvent","routeChangeEvent","pushState","loc","hash","prefix","redirectFromPath","redirectedFrom","RouterLink","routerDirection","onClick","o","routerAnimation","mode","attrs","rel","target","h","H","class","color","style"],"mappings":"iTAKA,MAAMA,EAAQ,MACZ,YAAYC,IACV,IAAAC,GAAiBC,KAAMF,GACvBE,KAAKC,qBAAsB,OAAYD,KAAM,sBAAuB,GAOpEA,KAAKE,IAAM,GAEb,SAASC,GACPH,KAAKC,oBAAoBG,KAAKD,GAEhC,iBAAiBA,EAAUE,GACzB,GAAIF,IAAaE,EACf,OAEF,MAAMC,EAAQH,EAAWI,OAAOC,KAAKL,GAAY,GAC3CM,EAAQJ,EAAWE,OAAOC,KAAKH,GAAY,GACjD,GAAIC,EAAMI,SAAWD,EAAMC,OAAO,CAIlC,IAAK,MAAMC,KAAOL,EAChB,GAAIH,EAASQ,KAASN,EAASM,GAE7B,YADAX,KAAKY,SAAST,QALhBH,KAAKY,SAAST,GAUlB,oBACEH,KAAKC,oBAAoBG,OAE3B,sBAAwB,MAAO,CAC7B,IAAO,CAAC,YACR,UAAa,CAAC,YACd,eAAkB,CAAC,uBAIjBS,EAAgB,MACpB,YAAYf,IACV,IAAAC,GAAiBC,KAAMF,GACvBE,KAAKc,yBAA0B,OAAYd,KAAM,0BAA2B,GAE9E,gBACEA,KAAKc,wBAAwBV,OAE/B,oBACEJ,KAAKc,wBAAwBV,OAE/B,sBAAwB,MAAO,CAC7B,KAAQ,CAAC,iBACT,GAAM,CAAC,oBAQLW,EAAgBC,GAIb,IAHMA,EACVC,OAAOC,GAAKA,EAAER,OAAS,GACvBS,KAAK,KAoEJC,EAAaC,IACjB,GAAY,MAARA,EACF,MAAO,CAAC,IAEV,MACML,EADoBK,EAAKC,MAAM,KAAK,GACPA,MAAM,KACtCC,IAAIL,GAAKA,EAAEM,QACXP,OAAOC,GAAKA,EAAER,OAAS,GAC1B,OAAwB,IAApBM,EAASN,OACJ,CAAC,IAGDM,GAwBLS,EAAgBC,MAAOC,EAAMC,EAAOC,EAAWC,EAAOC,GAAU,EAAOC,KAC3E,IAEE,MAAMC,EAASC,EAAcP,GAE7B,GAAIG,GAASF,EAAMlB,SAAWuB,EAC5B,OAAOF,QAEH,IAAII,QAAQC,IAAW,IAAAC,GAAiBJ,EAAQG,IACtD,MAAME,EAAQV,EAAME,GACdS,QAAeN,EAAOO,WAAWF,EAAMG,GAAIH,EAAMI,OAAQb,EAAWG,GAc1E,OAXIO,EAAOR,UACTF,EA7HqB,OA8HrBE,GAAU,GAGZA,QAAgBN,EAAcc,EAAOI,QAASf,EAAOC,EAAWC,EAAQ,EAAGC,EAASC,GAGhFO,EAAOK,mBACHL,EAAOK,cAERb,EAET,MAAOc,GAEL,OADAC,QAAQC,MAAMF,IACP,IAmCLG,EAAQ,6FACRd,EAAiBP,IACrB,IAAKA,EACH,OAEF,GAAIA,EAAKsB,QAAQD,GACf,OAAOrB,EAET,MAAMM,EAASN,EAAKuB,cAAcF,GAClC,OAAOf,QAAkBkB,GAsBrBC,EAAgB,CAAC/B,EAAMgC,IACpBA,EAAOC,KAAKhB,GApBG,EAACiB,EAAOjB,KAC9B,MAAM,KAAEkB,EAAI,GAAEC,GAAOnB,EACrB,QAAWa,IAAPM,EACF,OAAO,EAET,GAAID,EAAK9C,OAAS6C,EAAM7C,OACtB,OAAO,EAET,IAAK,IAAIgD,EAAI,EAAGA,EAAIF,EAAK9C,OAAQgD,IAAK,CACpC,MAAMC,EAAWH,EAAKE,GACtB,GAAiB,MAAbC,EACF,OAAO,EAET,GAAIA,IAAaJ,EAAMG,GACrB,OAAO,EAGX,OAAOF,EAAK9C,SAAW6C,EAAM7C,QAjBP,CAoBsBW,EAAMiB,IAE9CsB,EAAa,CAACC,EAAKjC,KACvB,MAAMkC,EAAMC,KAAKC,IAAIH,EAAInD,OAAQkB,EAAMlB,QACvC,IAAIgD,EAAI,EACR,KAAOA,EAAII,GACLD,EAAIH,GAAGO,gBAAkBrC,EAAM8B,GAAGjB,GADxBiB,KAKhB,OAAOA,GAEHQ,EAAc,CAACC,EAAWvC,KAC9B,MAAMZ,EAAW,IAAIoD,EAAeD,GACpC,IACIE,EADAC,GAAiB,EAErB,IAAK,IAAIZ,EAAI,EAAGA,EAAI9B,EAAMlB,OAAQgD,IAAK,CACrC,MAAMrC,EAAOO,EAAM8B,GAAGrC,KACtB,GAAgB,KAAZA,EAAK,GACPiD,GAAiB,MAEd,CACH,IAAK,MAAMC,KAAWlD,EAAM,CAC1B,MAAMmD,EAAOxD,EAASyD,OAEtB,GAAmB,MAAfF,EAAQ,GAAY,CACtB,GAAa,KAATC,EACF,OAAO,KAETH,EAAYA,GAAa,IACVA,EAAUX,KAAOW,EAAUX,GAAK,KACxCa,EAAQG,MAAM,IAAMF,OAExB,GAAIA,IAASD,EAChB,OAAO,KAGXD,GAAiB,GAMrB,OAHgB,GACZA,KAAwC,KAApBtD,EAASyD,QAK7BJ,EACKzC,EAAML,IAAI,CAACe,EAAOoB,MACvBjB,GAAIH,EAAMG,GACVpB,KAAMiB,EAAMjB,KACZqB,OAAQiC,EAAYrC,EAAMI,OAAQ2B,EAAUX,IAC5CkB,YAAatC,EAAMsC,YACnBC,YAAavC,EAAMuC,eAGhBjD,EAXE,MAeL+C,EAAc,CAACG,EAAGC,IACfD,GAAKC,EAAIxE,OAAOyE,OAAOzE,OAAOyE,OAAO,GAAIF,GAAIC,QAAK5B,EAsBrD8B,EAAoB,CAAC5D,EAAM6D,KAC/B,IAAIC,EAAQ,KACRlC,EAAU,EACd,IAAK,MAAMrB,KAASsD,EAAQ,CAC1B,MAAME,EAAelB,EAAY7C,EAAMO,GACvC,GAAqB,OAAjBwD,EAAuB,CACzB,MAAMC,EAAQC,EAAgBF,GAC1BC,EAAQpC,IACVA,EAAUoC,EACVF,EAAQC,IAId,OAAOD,GAEHG,EAAmB1D,IACvB,IAAIyD,EAAQ,EACRE,EAAQ,EACZ,IAAK,MAAMjD,KAASV,EAClB,IAAK,MAAMP,KAAQiB,EAAMjB,KACP,MAAZA,EAAK,GACPgE,GAAStB,KAAKyB,IAAI,EAAGD,GAEL,KAATlE,IACPgE,GAAStB,KAAKyB,IAAI,EAAGD,IAEvBA,IAGJ,OAAOF,GAET,MAAMjB,EACJ,YAAY/C,GACVrB,KAAKqB,KAAOA,EAAKqD,QAEnB,OACE,OAAI1E,KAAKqB,KAAKX,OAAS,EACdV,KAAKqB,KAAKoE,QAEZ,IAIX,MAAMC,EAAiB/D,GACdgE,MAAMnC,KAAK7B,EAAKiE,UACpB3E,OAAO4E,GAAqB,uBAAfA,EAAGC,SAChBvE,IAAIsE,IACL,MAAMpC,EAAKsC,EAASF,EAAI,MACxB,MAAO,CACLrC,KAAMpC,EAAU2E,EAASF,EAAI,SAC7BpC,GAAU,MAANA,OAAaN,EAAY/B,EAAUqC,MAIvCuC,EAAcrE,GACXsE,EAAkBC,EAAevE,IAEpCuE,EAAiB,CAACvE,EAAMwE,EAAOxE,IAC5BgE,MAAMnC,KAAK2C,EAAKP,UACpB3E,OAAO4E,GAAqB,cAAfA,EAAGC,SAA2BD,EAAGO,WAC9C7E,IAAIsE,IACL,MAAMO,EAAYL,EAASF,EAAI,aAC/B,GAAiB,MAAbO,EACF,MAAM,IAAIC,MAAM,kCAElB,MAAO,CACLhF,KAAMD,EAAU2E,EAASF,EAAI,QAC7BpD,GAAI2D,EAAUnC,cACdvB,OAAQmD,EAAGS,eACXzB,YAAagB,EAAGhB,YAChBD,YAAaiB,EAAGjB,YAChBgB,SAAUM,EAAevE,EAAMkE,MAI/BE,EAAW,CAACF,EAAIU,IAChBA,KAAQV,EACHA,EAAGU,GAERV,EAAGW,aAAaD,GACXV,EAAGY,aAAaF,GAElB,KAEHN,EAAqBS,IACzB,MAAMrD,EAAS,GACf,IAAK,MAAM8C,KAAQO,EACjBC,EAAY,GAAItD,EAAQ8C,GAE1B,OAAO9C,GAEHsD,EAAc,CAAC/E,EAAOyB,EAAQ8C,KAClC,MAAMjF,EAAIU,EAAM8C,QAQhB,GAPAxD,EAAE0F,KAAK,CACLnE,GAAI0D,EAAK1D,GACTpB,KAAM8E,EAAK9E,KACXqB,OAAQyD,EAAKzD,OACbmC,YAAasB,EAAKtB,YAClBD,YAAauB,EAAKvB,cAES,IAAzBuB,EAAKP,SAASlF,OAIlB,IAAK,MAAMmG,KAAOV,EAAKP,SACrBe,EAAYzF,EAAGmC,EAAQwD,QAJvBxD,EAAOuD,KAAK1F,IAQV4F,EAAS,MACb,YAAYhH,IACV,IAAAC,GAAiBC,KAAMF,GACvBE,KAAK+G,oBAAqB,OAAY/G,KAAM,qBAAsB,GAClEA,KAAKgH,mBAAoB,OAAYhH,KAAM,oBAAqB,GAChEA,KAAKiH,aAAe,KACpBjH,KAAKkH,MAAO,EACZlH,KAAKmH,MAAQ,EACbnH,KAAKoH,UAAY,EAMjBpH,KAAK2B,KAAO,IAeZ3B,KAAKqH,SAAU,EAEjB,0BACEvE,QAAQwE,MAAM,uCAtQZpF,EAAcqF,SAASC,MAClBrF,QAAQC,UAEV,IAAID,QAAQC,IACjBqF,OAAOC,iBAAiB,iBAAkBtF,EAAS,CAAEuF,MAAM,OAoQ3D7E,QAAQwE,MAAM,gCACRtH,KAAK4H,kBAEb,mBACEH,OAAOC,iBAAiB,2BAA2B,OAAS1H,KAAK6H,kBAAkBC,KAAK9H,MAAO,KAC/FyH,OAAOC,iBAAiB,uBAAuB,OAAS1H,KAAK4H,gBAAgBE,KAAK9H,MAAO,MAE3F,mBACE,MAAM6B,EAAY7B,KAAK+H,mBACvB,IAAI1G,EAAOrB,KAAKgI,UAChB,MAAMC,QAAmBjI,KAAKkI,UAAU7G,GACxC,OAAmB,IAAf4G,GACwB,iBAAfA,IACT5G,EAAOD,EAAU6G,EAAWE,YAEvB,IAETrF,QAAQwE,MAAM,yCAA0CjG,EAAMQ,GACvD7B,KAAKoI,kBAAkB/G,EAAMQ,IAEtC,aAAawG,GACXA,EAAGC,OAAOC,SAAS,EAAGC,IACpBxI,KAAKyI,OACLD,MAIJ,sBACE,MAAMP,QAAmBjI,KAAKkI,YAC9B,OAAmB,IAAfD,GACwB,iBAAfA,GACFA,EAAWE,SAcxB,WAAWjI,EAAK2B,EAAY,UAAWG,GACjC9B,EAAIwI,WAAW,OACjBxI,EAAM,IAAKyI,IAAIzI,EAAKuH,OAAOmB,SAASC,MAAOC,UAE7ChG,QAAQwE,MAAM,0CAA2CpH,EAAK2B,GAC9D,IAAIR,EAAOD,EAAUlB,GACjB6I,EAAc7I,EAAIoB,MAAM,KAAK,GACjC,MAAM2G,QAAmBjI,KAAKkI,UAAU7G,GACxC,IAAmB,IAAf4G,EAAqB,CACvB,GAA0B,iBAAfA,EAKT,OAAO,EAJP5G,EAAOD,EAAU6G,EAAWE,UAC5BY,EAAcd,EAAWE,SAAS7G,MAAM,KAAK,GAOjD,OADAtB,KAAKgJ,QAAQ3H,EAAMQ,EAAWkH,GACvB/I,KAAKoI,kBAAkB/G,EAAMQ,EAAWG,GAKjD,OAEE,OADAyF,OAAOwB,QAAQR,OACRtG,QAAQC,QAAQpC,KAAKkJ,aAG9B,mBACEpG,QAAQwE,MAAM,eAAgBtH,KAAKgI,WACnClF,QAAQwE,MAAM,gBAAiBtH,KAAKiH,cA/ZpB,CAAC5D,IACnBP,QAAQqG,MAAM,qBAAqB9F,EAAO3C,WAC1C,IAAK,MAAMkB,KAASyB,EAAQ,CAC1B,MAAMhC,EAAO,GACbO,EAAMwH,QAAQrJ,GAAKsB,EAAKuF,QAAQ7G,EAAEsB,OAClC,MAAMwC,EAAMjC,EAAML,IAAIxB,GAAKA,EAAE0C,IAC7BK,QAAQwE,MAAM,MAAMvG,EAAaM,KAAS,wCAAyC,OAAQ,IAAIwC,EAAI1C,KAAK,UAE1G2B,QAAQuG,YARU,CAgaJrD,EAAWhG,KAAK6F,KAtZT,CAACyD,IACtBxG,QAAQqG,MAAM,wBAAwBG,EAAU5I,WAChD,IAAK,MAAMyH,KAAYmB,EACjBnB,EAAS1E,IACXX,QAAQwE,MAAM,SAAU,MAAMvG,EAAaoH,EAAS3E,QAAS,oBAAqB,QAAS,MAAMzC,EAAaoH,EAAS1E,MAAO,qBAGlIX,QAAQuG,YAPa,CAuZJ3D,EAAc1F,KAAK6F,KAGpC,iBAAiBhE,GACf,GAAI7B,KAAKkH,KAEP,OADApE,QAAQyG,KAAK,0DACN,EAET,MAAM,IAAE1F,EAAG,OAAE5B,QAtXIP,WACnB,MAAMmC,EAAM,GACZ,IAAI5B,EACAkE,EAAOxE,EAEX,KACEM,EAASC,EAAciE,GACnBlE,GAAQ,CACV,MAAMQ,QAAWR,EAAOuH,aACxB,IAAI/G,EAMF,MALA0D,EAAO1D,EAAGE,QACVF,EAAGE,aAAUQ,EACbU,EAAI+C,KAAKnE,GAUf,MAAO,CAAEoB,MAAK5B,WAtBKP,CAsX0B+F,OAAOF,SAASC,MAErD5F,EA1Pe,EAACiC,EAAKqB,KAC7B,IAAIC,EAAQ,KACRsE,EAAa,EACjB,MAAMC,EAAW7F,EAAItC,IAAImC,GAAKA,EAAEjB,IAChC,IAAK,MAAMb,KAASsD,EAAQ,CAC1B,MAAMG,EAAQzB,EAAW8F,EAAU9H,GAC/ByD,EAAQoE,IACVtE,EAAQvD,EACR6H,EAAapE,GAGjB,OAAIF,EACKA,EAAM5D,IAAI,CAACe,EAAOoB,MACvBjB,GAAIH,EAAMG,GACVpB,KAAMiB,EAAMjB,KACZqB,OAAQiC,EAAYrC,EAAMI,OAAQmB,EAAIH,IAAMG,EAAIH,GAAGhB,WAGhD,MAlBgB,CA0PUmB,EADhBmC,EAAWhG,KAAK6F,KAE/B,IAAKjE,EAEH,OADAkB,QAAQyG,KAAK,oCAAqC1F,EAAItC,IAAImC,GAAKA,EAAEjB,MAC1D,EAET,MAAMpB,EAjgBU,CAACO,IACnB,MAAMP,EAAO,GACb,IAAK,MAAMiB,KAASV,EAClB,IAAK,MAAM2C,KAAWjC,EAAMjB,KAC1B,GAAmB,MAAfkD,EAAQ,GAAY,CACtB,MAAMoF,EAAQrH,EAAMI,QAAUJ,EAAMI,OAAO6B,EAAQG,MAAM,IACzD,IAAKiF,EACH,OAAO,KAETtI,EAAKuF,KAAK+C,OAES,KAAZpF,GACPlD,EAAKuF,KAAKrC,GAIhB,OAAOlD,GAhBW,CAigBSO,GACzB,OAAKP,GAILyB,QAAQwE,MAAM,yCAA0CzD,EAAKxC,GAC7DrB,KAAKgJ,QAAQ3H,EAAMQ,SACb7B,KAAK4J,kBAAkB3H,EAAQL,EAlhBd,OAkhByCP,EAAM,KAAMwC,EAAInD,SACzE,IANLoC,QAAQyG,KAAK,oFACN,GAOX,oBACE,MAAMlI,EAAOrB,KAAKgI,UACd3G,GAAQ+B,EAAc/B,EAAMqE,EAAc1F,KAAK6F,MACjD7F,KAAKoI,kBAAkB/G,EAxhBF,QA2hBzB,kBACE,OAAOrB,KAAKoI,kBAAkBpI,KAAKgI,UA5hBZ,QA8hBzB,mBACE,MAAM6B,EAAMpC,OACc,OAAtBoC,EAAIZ,QAAQ9B,QACdnH,KAAKmH,QACL0C,EAAIZ,QAAQa,aAAa9J,KAAKmH,MAAO0C,EAAItC,SAASwC,MAAOF,EAAItC,SAASqB,UAAYiB,EAAItC,SAASqB,SAASC,OAE1G,MAAM1B,EAAQ0C,EAAIZ,QAAQ9B,MACpBC,EAAYpH,KAAKoH,UAEvB,OADApH,KAAKoH,UAAYD,EACbA,EAAQC,GAAcD,GAASC,GAAaA,EAAY,EAtiBlC,UAyiBjBD,EAAQC,EAxiBM,OAFA,OAijBzB,wBAAwB/F,EAAMQ,EAAWG,GACvC,IAAKX,EAEH,OADAyB,QAAQC,MAAM,oDACP,EAGT,MAAMuG,EAAY5D,EAAc1F,KAAK6F,IAC/BsC,EAAW/E,EAAc/B,EAAMiI,GACrC,IAAIU,EAAe,KACf7B,IACFnI,KAAKgJ,QAAQb,EAAS1E,GAAI5B,GAC1BmI,EAAe7B,EAAS3E,KACxBnC,EAAO8G,EAAS1E,IAGlB,MAAMJ,EAAS2C,EAAWhG,KAAK6F,IACzBjE,EAAQqD,EAAkB5D,EAAMgC,GACtC,OAAKzB,EAKE5B,KAAK4J,kBAAkBrC,SAASC,KAAM5F,EAAOC,EAAWR,EAAM2I,EAAc,EAAGhI,IAJpFc,QAAQC,MAAM,mDACP,GAKX,wBAAwBoD,EAAMvE,EAAOC,EAAWR,EAAM2I,EAAclI,EAAQ,EAAGE,GAC7E,MAAMiI,QAAejK,KAAKkK,OAC1B,IAAInI,GAAU,EACd,IACEA,QAAgB/B,KAAKyB,cAAc0E,EAAMvE,EAAOC,EAAWR,EAAM2I,EAAclI,EAAOE,GAExF,MAAOa,GACLC,QAAQC,MAAMF,GAGhB,OADAoH,IACOlI,EAET,aACE,MAAMoI,EAAInK,KAAKkJ,YACf,IAAI9G,EAKJ,OAJApC,KAAKkJ,YAAc,IAAI/G,QAAQpC,GAAKqC,EAAUrC,QACpCoD,IAANgH,SACIA,EAED/H,EAET,gBAAgBqB,EAAKzD,KAAKgI,UAAWxE,EAAOpC,EAAUpB,KAAKiH,eACzD,IAAKxD,IAAOD,EACV,OAAO,EAET,MAAMH,EAAS2C,EAAWhG,KAAK6F,IACzBuE,EAAUnF,EAAkBxB,EAAIJ,GAChCgH,EAAYpF,EAAkBzB,EAAMH,GACpCiH,EAAkBF,GAAWA,EAAQA,EAAQ1J,OAAS,GAAGkE,YACzD2F,EAAkBF,GAAaA,EAAUA,EAAU3J,OAAS,GAAGmE,YAC/D2F,GAAWD,SAAwBA,IACzC,IAAiB,IAAbC,GAA0C,iBAAbA,EAC/B,OAAOA,EAET,MAAMC,GAAWH,SAAwBA,IACzC,OAAiB,IAAbG,GAA0C,iBAAbA,GACxBA,EAIX,oBAAoBtE,EAAMvE,EAAOC,EAAWR,EAAM2I,EAAclI,EAAQ,EAAGE,GACzE,GAAIhC,KAAKkH,KAEP,OADApE,QAAQyG,KAAK,0DACN,EAETvJ,KAAKkH,MAAO,EAEZ,MAAMwD,EAAa1K,KAAK2K,iBAAiBtJ,EAAM2I,GAC3CU,GACF1K,KAAK+G,mBAAmB3G,KAAKsK,GAE/B,MAAM3I,QAAgBN,EAAc0E,EAAMvE,EAAOC,EAAWC,GAAO,EAAOE,GAS1E,OARAhC,KAAKkH,MAAO,EACRnF,GACFe,QAAQwE,MAAM,6BAA8BjG,GAG1CqJ,GACF1K,KAAKgH,kBAAkB5G,KAAKsK,GAEvB3I,EAET,QAAQV,EAAMQ,EAAWkH,GACvB/I,KAAKmH,QA5mBS,EAAC8B,EAAStH,EAAM0F,EAAShG,EAAMQ,EAAWsF,EAAO4B,KACjE,IAAI7I,EAAMa,EAAa,IAClBK,EAAUO,MACVN,IAEDgG,IACFnH,EAAM,IAAMA,QAEMiD,IAAhB4F,IACF7I,EAAMA,EAAM,IAAM6I,GApCQ,YAsCxBlH,EACFoH,EAAQ2B,UAAUzD,EAAO,GAAIjH,GAG7B+I,EAAQa,aAAa3C,EAAO,GAAIjH,IAflB,CA6mBJuH,OAAOwB,QAASjJ,KAAK2B,KAAM3B,KAAKqH,QAAShG,EAAMQ,EAAW7B,KAAKmH,MAAO4B,GAElF,UACE,MA7kBa,EAAC8B,EAAKlJ,EAAM0F,KAC3B,IAAIyB,EAAW+B,EAAI/B,SACnB,GAAIzB,EAAS,CACX,MAAMyD,EAAOD,EAAIC,KACjBhC,EAAwB,MAAZgC,EAAK,GACbA,EAAKpG,MAAM,GACX,GAIN,MA3BmB,EAACqG,EAAQ1J,KAC5B,GAAI0J,EAAOrK,OAASW,EAAKX,OACvB,OAAO,KAET,GAAIqK,EAAOrK,QAAU,GAAmB,KAAdqK,EAAO,GAC/B,OAAO1J,EAET,IAAK,IAAIqC,EAAI,EAAGA,EAAIqH,EAAOrK,OAAQgD,IACjC,GAAIqH,EAAOrH,GAAGhD,OAAS,GAAKqK,EAAOrH,KAAOrC,EAAKqC,GAC7C,OAAO,KAGX,OAAIrC,EAAKX,SAAWqK,EAAOrK,OAClB,CAAC,IAEHW,EAAKqD,MAAMqG,EAAOrK,SAfN,CAyBJU,EAAUO,GACZP,EAAU0H,KATR,CA6kBGrB,OAAOmB,SAAU5I,KAAK2B,KAAM3B,KAAKqH,SAEnD,iBAAiBhG,EAAM2J,GACrB,MAAMxH,EAAOxD,KAAKiH,aACZxD,EAAK1C,EAAaM,GAExB,GADArB,KAAKiH,aAAexD,EAChBA,IAAOD,EACT,OAAO,KAGT,MAAO,CACLA,OACAyH,eAHqBD,EAAmBjK,EAAaiK,GAAoB,KAIzEvH,MAGJ,SAAW,OAAO,OAAWzD,QAKzBkL,EAAa,MACjB,YAAYpL,IACV,IAAAC,GAAiBC,KAAMF,GAKvBE,KAAKmL,gBAAkB,UACvBnL,KAAKoL,QAAW/C,KACd,IAAAgD,GAAQrL,KAAK6I,KAAMR,EAAIrI,KAAKmL,gBAAiBnL,KAAKsL,kBAGtD,SACE,MAAMC,GAAO,OAAWvL,MAClBwL,EAAQ,CACZ3C,KAAM7I,KAAK6I,KACX4C,IAAKzL,KAAKyL,IACVC,OAAQ1L,KAAK0L,QAEf,OAAQ,IAAAC,GAAE,EAAAC,EAAM,CAAER,QAASpL,KAAKoL,QAASS,OAAO,IAAAxJ,GAAmBrC,KAAK8L,MAAO,CAC3E,CAACP,IAAO,EACR,mBAAmB,MACf,IAAAI,GAAE,IAAKpL,OAAOyE,OAAO,GAAIwG,IAAQ,IAAAG,GAAE,OAAQ,UAGvDT,EAAWa,MA3BW","file":"x","sourcesContent":["import { r as registerInstance, e as createEvent, i as getElement, h, H as Host } from './index-7a8b7a1c.js';\r\nimport { c as componentOnReady, n as debounce } from './helpers-dd7e4b7b.js';\r\nimport { b as getIonMode } from './ionic-global-63a97a32.js';\r\nimport { o as openURL, c as createColorClasses } from './theme-ff3fc52f.js';\r\n\r\nconst Route = class {\r\n  constructor(hostRef) {\r\n    registerInstance(this, hostRef);\r\n    this.ionRouteDataChanged = createEvent(this, \"ionRouteDataChanged\", 7);\r\n    /**\r\n     * Relative path that needs to match in order for this route to apply.\r\n     *\r\n     * Accepts paths similar to expressjs so that you can define parameters\r\n     * in the url /foo/:bar where bar would be available in incoming props.\r\n     */\r\n    this.url = '';\r\n  }\r\n  onUpdate(newValue) {\r\n    this.ionRouteDataChanged.emit(newValue);\r\n  }\r\n  onComponentProps(newValue, oldValue) {\r\n    if (newValue === oldValue) {\r\n      return;\r\n    }\r\n    const keys1 = newValue ? Object.keys(newValue) : [];\r\n    const keys2 = oldValue ? Object.keys(oldValue) : [];\r\n    if (keys1.length !== keys2.length) {\r\n      this.onUpdate(newValue);\r\n      return;\r\n    }\r\n    for (const key of keys1) {\r\n      if (newValue[key] !== oldValue[key]) {\r\n        this.onUpdate(newValue);\r\n        return;\r\n      }\r\n    }\r\n  }\r\n  connectedCallback() {\r\n    this.ionRouteDataChanged.emit();\r\n  }\r\n  static get watchers() { return {\r\n    \"url\": [\"onUpdate\"],\r\n    \"component\": [\"onUpdate\"],\r\n    \"componentProps\": [\"onComponentProps\"]\r\n  }; }\r\n};\r\n\r\nconst RouteRedirect = class {\r\n  constructor(hostRef) {\r\n    registerInstance(this, hostRef);\r\n    this.ionRouteRedirectChanged = createEvent(this, \"ionRouteRedirectChanged\", 7);\r\n  }\r\n  propDidChange() {\r\n    this.ionRouteRedirectChanged.emit();\r\n  }\r\n  connectedCallback() {\r\n    this.ionRouteRedirectChanged.emit();\r\n  }\r\n  static get watchers() { return {\r\n    \"from\": [\"propDidChange\"],\r\n    \"to\": [\"propDidChange\"]\r\n  }; }\r\n};\r\n\r\nconst ROUTER_INTENT_NONE = 'root';\r\nconst ROUTER_INTENT_FORWARD = 'forward';\r\nconst ROUTER_INTENT_BACK = 'back';\r\n\r\nconst generatePath = (segments) => {\r\n  const path = segments\r\n    .filter(s => s.length > 0)\r\n    .join('/');\r\n  return '/' + path;\r\n};\r\nconst chainToPath = (chain) => {\r\n  const path = [];\r\n  for (const route of chain) {\r\n    for (const segment of route.path) {\r\n      if (segment[0] === ':') {\r\n        const param = route.params && route.params[segment.slice(1)];\r\n        if (!param) {\r\n          return null;\r\n        }\r\n        path.push(param);\r\n      }\r\n      else if (segment !== '') {\r\n        path.push(segment);\r\n      }\r\n    }\r\n  }\r\n  return path;\r\n};\r\nconst writePath = (history, root, useHash, path, direction, state, queryString) => {\r\n  let url = generatePath([\r\n    ...parsePath(root),\r\n    ...path\r\n  ]);\r\n  if (useHash) {\r\n    url = '#' + url;\r\n  }\r\n  if (queryString !== undefined) {\r\n    url = url + '?' + queryString;\r\n  }\r\n  if (direction === ROUTER_INTENT_FORWARD) {\r\n    history.pushState(state, '', url);\r\n  }\r\n  else {\r\n    history.replaceState(state, '', url);\r\n  }\r\n};\r\nconst removePrefix = (prefix, path) => {\r\n  if (prefix.length > path.length) {\r\n    return null;\r\n  }\r\n  if (prefix.length <= 1 && prefix[0] === '') {\r\n    return path;\r\n  }\r\n  for (let i = 0; i < prefix.length; i++) {\r\n    if (prefix[i].length > 0 && prefix[i] !== path[i]) {\r\n      return null;\r\n    }\r\n  }\r\n  if (path.length === prefix.length) {\r\n    return [''];\r\n  }\r\n  return path.slice(prefix.length);\r\n};\r\nconst readPath = (loc, root, useHash) => {\r\n  let pathname = loc.pathname;\r\n  if (useHash) {\r\n    const hash = loc.hash;\r\n    pathname = (hash[0] === '#')\r\n      ? hash.slice(1)\r\n      : '';\r\n  }\r\n  const prefix = parsePath(root);\r\n  const path = parsePath(pathname);\r\n  return removePrefix(prefix, path);\r\n};\r\nconst parsePath = (path) => {\r\n  if (path == null) {\r\n    return [''];\r\n  }\r\n  const removeQueryString = path.split('?')[0];\r\n  const segments = removeQueryString.split('/')\r\n    .map(s => s.trim())\r\n    .filter(s => s.length > 0);\r\n  if (segments.length === 0) {\r\n    return [''];\r\n  }\r\n  else {\r\n    return segments;\r\n  }\r\n};\r\n\r\nconst printRoutes = (routes) => {\r\n  console.group(`[ion-core] ROUTES[${routes.length}]`);\r\n  for (const chain of routes) {\r\n    const path = [];\r\n    chain.forEach(r => path.push(...r.path));\r\n    const ids = chain.map(r => r.id);\r\n    console.debug(`%c ${generatePath(path)}`, 'font-weight: bold; padding-left: 20px', '=>\\t', `(${ids.join(', ')})`);\r\n  }\r\n  console.groupEnd();\r\n};\r\nconst printRedirects = (redirects) => {\r\n  console.group(`[ion-core] REDIRECTS[${redirects.length}]`);\r\n  for (const redirect of redirects) {\r\n    if (redirect.to) {\r\n      console.debug('FROM: ', `$c ${generatePath(redirect.from)}`, 'font-weight: bold', ' TO: ', `$c ${generatePath(redirect.to)}`, 'font-weight: bold');\r\n    }\r\n  }\r\n  console.groupEnd();\r\n};\r\n\r\nconst writeNavState = async (root, chain, direction, index, changed = false, animation) => {\r\n  try {\r\n    // find next navigation outlet in the DOM\r\n    const outlet = searchNavNode(root);\r\n    // make sure we can continue interacting the DOM, otherwise abort\r\n    if (index >= chain.length || !outlet) {\r\n      return changed;\r\n    }\r\n    await new Promise(resolve => componentOnReady(outlet, resolve));\r\n    const route = chain[index];\r\n    const result = await outlet.setRouteId(route.id, route.params, direction, animation);\r\n    // if the outlet changed the page, reset navigation to neutral (no direction)\r\n    // this means nested outlets will not animate\r\n    if (result.changed) {\r\n      direction = ROUTER_INTENT_NONE;\r\n      changed = true;\r\n    }\r\n    // recursively set nested outlets\r\n    changed = await writeNavState(result.element, chain, direction, index + 1, changed, animation);\r\n    // once all nested outlets are visible let's make the parent visible too,\r\n    // using markVisible prevents flickering\r\n    if (result.markVisible) {\r\n      await result.markVisible();\r\n    }\r\n    return changed;\r\n  }\r\n  catch (e) {\r\n    console.error(e);\r\n    return false;\r\n  }\r\n};\r\nconst readNavState = async (root) => {\r\n  const ids = [];\r\n  let outlet;\r\n  let node = root;\r\n  // tslint:disable-next-line:no-constant-condition\r\n  while (true) {\r\n    outlet = searchNavNode(node);\r\n    if (outlet) {\r\n      const id = await outlet.getRouteId();\r\n      if (id) {\r\n        node = id.element;\r\n        id.element = undefined;\r\n        ids.push(id);\r\n      }\r\n      else {\r\n        break;\r\n      }\r\n    }\r\n    else {\r\n      break;\r\n    }\r\n  }\r\n  return { ids, outlet };\r\n};\r\nconst waitUntilNavNode = () => {\r\n  if (searchNavNode(document.body)) {\r\n    return Promise.resolve();\r\n  }\r\n  return new Promise(resolve => {\r\n    window.addEventListener('ionNavWillLoad', resolve, { once: true });\r\n  });\r\n};\r\nconst QUERY = ':not([no-router]) ion-nav, :not([no-router]) ion-tabs, :not([no-router]) ion-router-outlet';\r\nconst searchNavNode = (root) => {\r\n  if (!root) {\r\n    return undefined;\r\n  }\r\n  if (root.matches(QUERY)) {\r\n    return root;\r\n  }\r\n  const outlet = root.querySelector(QUERY);\r\n  return outlet ? outlet : undefined;\r\n};\r\n\r\nconst matchesRedirect = (input, route) => {\r\n  const { from, to } = route;\r\n  if (to === undefined) {\r\n    return false;\r\n  }\r\n  if (from.length > input.length) {\r\n    return false;\r\n  }\r\n  for (let i = 0; i < from.length; i++) {\r\n    const expected = from[i];\r\n    if (expected === '*') {\r\n      return true;\r\n    }\r\n    if (expected !== input[i]) {\r\n      return false;\r\n    }\r\n  }\r\n  return from.length === input.length;\r\n};\r\nconst routeRedirect = (path, routes) => {\r\n  return routes.find(route => matchesRedirect(path, route));\r\n};\r\nconst matchesIDs = (ids, chain) => {\r\n  const len = Math.min(ids.length, chain.length);\r\n  let i = 0;\r\n  for (; i < len; i++) {\r\n    if (ids[i].toLowerCase() !== chain[i].id) {\r\n      break;\r\n    }\r\n  }\r\n  return i;\r\n};\r\nconst matchesPath = (inputPath, chain) => {\r\n  const segments = new RouterSegments(inputPath);\r\n  let matchesDefault = false;\r\n  let allparams;\r\n  for (let i = 0; i < chain.length; i++) {\r\n    const path = chain[i].path;\r\n    if (path[0] === '') {\r\n      matchesDefault = true;\r\n    }\r\n    else {\r\n      for (const segment of path) {\r\n        const data = segments.next();\r\n        // data param\r\n        if (segment[0] === ':') {\r\n          if (data === '') {\r\n            return null;\r\n          }\r\n          allparams = allparams || [];\r\n          const params = allparams[i] || (allparams[i] = {});\r\n          params[segment.slice(1)] = data;\r\n        }\r\n        else if (data !== segment) {\r\n          return null;\r\n        }\r\n      }\r\n      matchesDefault = false;\r\n    }\r\n  }\r\n  const matches = (matchesDefault)\r\n    ? matchesDefault === (segments.next() === '')\r\n    : true;\r\n  if (!matches) {\r\n    return null;\r\n  }\r\n  if (allparams) {\r\n    return chain.map((route, i) => ({\r\n      id: route.id,\r\n      path: route.path,\r\n      params: mergeParams(route.params, allparams[i]),\r\n      beforeEnter: route.beforeEnter,\r\n      beforeLeave: route.beforeLeave\r\n    }));\r\n  }\r\n  return chain;\r\n};\r\n// Merges the route parameter objects.\r\n// Returns undefined when both parameters are undefined.\r\nconst mergeParams = (a, b) => {\r\n  return a || b ? Object.assign(Object.assign({}, a), b) : undefined;\r\n};\r\nconst routerIDsToChain = (ids, chains) => {\r\n  let match = null;\r\n  let maxMatches = 0;\r\n  const plainIDs = ids.map(i => i.id);\r\n  for (const chain of chains) {\r\n    const score = matchesIDs(plainIDs, chain);\r\n    if (score > maxMatches) {\r\n      match = chain;\r\n      maxMatches = score;\r\n    }\r\n  }\r\n  if (match) {\r\n    return match.map((route, i) => ({\r\n      id: route.id,\r\n      path: route.path,\r\n      params: mergeParams(route.params, ids[i] && ids[i].params)\r\n    }));\r\n  }\r\n  return null;\r\n};\r\nconst routerPathToChain = (path, chains) => {\r\n  let match = null;\r\n  let matches = 0;\r\n  for (const chain of chains) {\r\n    const matchedChain = matchesPath(path, chain);\r\n    if (matchedChain !== null) {\r\n      const score = computePriority(matchedChain);\r\n      if (score > matches) {\r\n        matches = score;\r\n        match = matchedChain;\r\n      }\r\n    }\r\n  }\r\n  return match;\r\n};\r\nconst computePriority = (chain) => {\r\n  let score = 1;\r\n  let level = 1;\r\n  for (const route of chain) {\r\n    for (const path of route.path) {\r\n      if (path[0] === ':') {\r\n        score += Math.pow(1, level);\r\n      }\r\n      else if (path !== '') {\r\n        score += Math.pow(2, level);\r\n      }\r\n      level++;\r\n    }\r\n  }\r\n  return score;\r\n};\r\nclass RouterSegments {\r\n  constructor(path) {\r\n    this.path = path.slice();\r\n  }\r\n  next() {\r\n    if (this.path.length > 0) {\r\n      return this.path.shift();\r\n    }\r\n    return '';\r\n  }\r\n}\r\n\r\nconst readRedirects = (root) => {\r\n  return Array.from(root.children)\r\n    .filter(el => el.tagName === 'ION-ROUTE-REDIRECT')\r\n    .map(el => {\r\n    const to = readProp(el, 'to');\r\n    return {\r\n      from: parsePath(readProp(el, 'from')),\r\n      to: to == null ? undefined : parsePath(to),\r\n    };\r\n  });\r\n};\r\nconst readRoutes = (root) => {\r\n  return flattenRouterTree(readRouteNodes(root));\r\n};\r\nconst readRouteNodes = (root, node = root) => {\r\n  return Array.from(node.children)\r\n    .filter(el => el.tagName === 'ION-ROUTE' && el.component)\r\n    .map(el => {\r\n    const component = readProp(el, 'component');\r\n    if (component == null) {\r\n      throw new Error('component missing in ion-route');\r\n    }\r\n    return {\r\n      path: parsePath(readProp(el, 'url')),\r\n      id: component.toLowerCase(),\r\n      params: el.componentProps,\r\n      beforeLeave: el.beforeLeave,\r\n      beforeEnter: el.beforeEnter,\r\n      children: readRouteNodes(root, el)\r\n    };\r\n  });\r\n};\r\nconst readProp = (el, prop) => {\r\n  if (prop in el) {\r\n    return el[prop];\r\n  }\r\n  if (el.hasAttribute(prop)) {\r\n    return el.getAttribute(prop);\r\n  }\r\n  return null;\r\n};\r\nconst flattenRouterTree = (nodes) => {\r\n  const routes = [];\r\n  for (const node of nodes) {\r\n    flattenNode([], routes, node);\r\n  }\r\n  return routes;\r\n};\r\nconst flattenNode = (chain, routes, node) => {\r\n  const s = chain.slice();\r\n  s.push({\r\n    id: node.id,\r\n    path: node.path,\r\n    params: node.params,\r\n    beforeLeave: node.beforeLeave,\r\n    beforeEnter: node.beforeEnter\r\n  });\r\n  if (node.children.length === 0) {\r\n    routes.push(s);\r\n    return;\r\n  }\r\n  for (const sub of node.children) {\r\n    flattenNode(s, routes, sub);\r\n  }\r\n};\r\n\r\nconst Router = class {\r\n  constructor(hostRef) {\r\n    registerInstance(this, hostRef);\r\n    this.ionRouteWillChange = createEvent(this, \"ionRouteWillChange\", 7);\r\n    this.ionRouteDidChange = createEvent(this, \"ionRouteDidChange\", 7);\r\n    this.previousPath = null;\r\n    this.busy = false;\r\n    this.state = 0;\r\n    this.lastState = 0;\r\n    /**\r\n     * By default `ion-router` will match the routes at the root path (\"/\").\r\n     * That can be changed when\r\n     *\r\n     */\r\n    this.root = '/';\r\n    /**\r\n     * The router can work in two \"modes\":\r\n     * - With hash: `/index.html#/path/to/page`\r\n     * - Without hash: `/path/to/page`\r\n     *\r\n     * Using one or another might depend in the requirements of your app and/or where it's deployed.\r\n     *\r\n     * Usually \"hash-less\" navigation works better for SEO and it's more user friendly too, but it might\r\n     * requires additional server-side configuration in order to properly work.\r\n     *\r\n     * On the otherside hash-navigation is much easier to deploy, it even works over the file protocol.\r\n     *\r\n     * By default, this property is `true`, change to `false` to allow hash-less URLs.\r\n     */\r\n    this.useHash = true;\r\n  }\r\n  async componentWillLoad() {\r\n    console.debug('[ion-router] router will load');\r\n    await waitUntilNavNode();\r\n    console.debug('[ion-router] found nav');\r\n    await this.onRoutesChanged();\r\n  }\r\n  componentDidLoad() {\r\n    window.addEventListener('ionRouteRedirectChanged', debounce(this.onRedirectChanged.bind(this), 10));\r\n    window.addEventListener('ionRouteDataChanged', debounce(this.onRoutesChanged.bind(this), 100));\r\n  }\r\n  async onPopState() {\r\n    const direction = this.historyDirection();\r\n    let path = this.getPath();\r\n    const canProceed = await this.runGuards(path);\r\n    if (canProceed !== true) {\r\n      if (typeof canProceed === 'object') {\r\n        path = parsePath(canProceed.redirect);\r\n      }\r\n      return false;\r\n    }\r\n    console.debug('[ion-router] URL changed -> update nav', path, direction);\r\n    return this.writeNavStateRoot(path, direction);\r\n  }\r\n  onBackButton(ev) {\r\n    ev.detail.register(0, processNextHandler => {\r\n      this.back();\r\n      processNextHandler();\r\n    });\r\n  }\r\n  /** @internal */\r\n  async canTransition() {\r\n    const canProceed = await this.runGuards();\r\n    if (canProceed !== true) {\r\n      if (typeof canProceed === 'object') {\r\n        return canProceed.redirect;\r\n      }\r\n      else {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n  /**\r\n   * Navigate to the specified URL.\r\n   *\r\n   * @param url The url to navigate to.\r\n   * @param direction The direction of the animation. Defaults to `\"forward\"`.\r\n   */\r\n  async push(url, direction = 'forward', animation) {\r\n    if (url.startsWith('.')) {\r\n      url = (new URL(url, window.location.href)).pathname;\r\n    }\r\n    console.debug('[ion-router] URL pushed -> updating nav', url, direction);\r\n    let path = parsePath(url);\r\n    let queryString = url.split('?')[1];\r\n    const canProceed = await this.runGuards(path);\r\n    if (canProceed !== true) {\r\n      if (typeof canProceed === 'object') {\r\n        path = parsePath(canProceed.redirect);\r\n        queryString = canProceed.redirect.split('?')[1];\r\n      }\r\n      else {\r\n        return false;\r\n      }\r\n    }\r\n    this.setPath(path, direction, queryString);\r\n    return this.writeNavStateRoot(path, direction, animation);\r\n  }\r\n  /**\r\n   * Go back to previous page in the window.history.\r\n   */\r\n  back() {\r\n    window.history.back();\r\n    return Promise.resolve(this.waitPromise);\r\n  }\r\n  /** @internal */\r\n  async printDebug() {\r\n    console.debug('CURRENT PATH', this.getPath());\r\n    console.debug('PREVIOUS PATH', this.previousPath);\r\n    printRoutes(readRoutes(this.el));\r\n    printRedirects(readRedirects(this.el));\r\n  }\r\n  /** @internal */\r\n  async navChanged(direction) {\r\n    if (this.busy) {\r\n      console.warn('[ion-router] router is busy, navChanged was cancelled');\r\n      return false;\r\n    }\r\n    const { ids, outlet } = await readNavState(window.document.body);\r\n    const routes = readRoutes(this.el);\r\n    const chain = routerIDsToChain(ids, routes);\r\n    if (!chain) {\r\n      console.warn('[ion-router] no matching URL for ', ids.map(i => i.id));\r\n      return false;\r\n    }\r\n    const path = chainToPath(chain);\r\n    if (!path) {\r\n      console.warn('[ion-router] router could not match path because some required param is missing');\r\n      return false;\r\n    }\r\n    console.debug('[ion-router] nav changed -> update URL', ids, path);\r\n    this.setPath(path, direction);\r\n    await this.safeWriteNavState(outlet, chain, ROUTER_INTENT_NONE, path, null, ids.length);\r\n    return true;\r\n  }\r\n  onRedirectChanged() {\r\n    const path = this.getPath();\r\n    if (path && routeRedirect(path, readRedirects(this.el))) {\r\n      this.writeNavStateRoot(path, ROUTER_INTENT_NONE);\r\n    }\r\n  }\r\n  onRoutesChanged() {\r\n    return this.writeNavStateRoot(this.getPath(), ROUTER_INTENT_NONE);\r\n  }\r\n  historyDirection() {\r\n    const win = window;\r\n    if (win.history.state === null) {\r\n      this.state++;\r\n      win.history.replaceState(this.state, win.document.title, win.document.location && win.document.location.href);\r\n    }\r\n    const state = win.history.state;\r\n    const lastState = this.lastState;\r\n    this.lastState = state;\r\n    if (state > lastState || (state >= lastState && lastState > 0)) {\r\n      return ROUTER_INTENT_FORWARD;\r\n    }\r\n    else if (state < lastState) {\r\n      return ROUTER_INTENT_BACK;\r\n    }\r\n    else {\r\n      return ROUTER_INTENT_NONE;\r\n    }\r\n  }\r\n  async writeNavStateRoot(path, direction, animation) {\r\n    if (!path) {\r\n      console.error('[ion-router] URL is not part of the routing set');\r\n      return false;\r\n    }\r\n    // lookup redirect rule\r\n    const redirects = readRedirects(this.el);\r\n    const redirect = routeRedirect(path, redirects);\r\n    let redirectFrom = null;\r\n    if (redirect) {\r\n      this.setPath(redirect.to, direction);\r\n      redirectFrom = redirect.from;\r\n      path = redirect.to;\r\n    }\r\n    // lookup route chain\r\n    const routes = readRoutes(this.el);\r\n    const chain = routerPathToChain(path, routes);\r\n    if (!chain) {\r\n      console.error('[ion-router] the path does not match any route');\r\n      return false;\r\n    }\r\n    // write DOM give\r\n    return this.safeWriteNavState(document.body, chain, direction, path, redirectFrom, 0, animation);\r\n  }\r\n  async safeWriteNavState(node, chain, direction, path, redirectFrom, index = 0, animation) {\r\n    const unlock = await this.lock();\r\n    let changed = false;\r\n    try {\r\n      changed = await this.writeNavState(node, chain, direction, path, redirectFrom, index, animation);\r\n    }\r\n    catch (e) {\r\n      console.error(e);\r\n    }\r\n    unlock();\r\n    return changed;\r\n  }\r\n  async lock() {\r\n    const p = this.waitPromise;\r\n    let resolve;\r\n    this.waitPromise = new Promise(r => resolve = r);\r\n    if (p !== undefined) {\r\n      await p;\r\n    }\r\n    return resolve;\r\n  }\r\n  async runGuards(to = this.getPath(), from = parsePath(this.previousPath)) {\r\n    if (!to || !from) {\r\n      return true;\r\n    }\r\n    const routes = readRoutes(this.el);\r\n    const toChain = routerPathToChain(to, routes);\r\n    const fromChain = routerPathToChain(from, routes);\r\n    const beforeEnterHook = toChain && toChain[toChain.length - 1].beforeEnter;\r\n    const beforeLeaveHook = fromChain && fromChain[fromChain.length - 1].beforeLeave;\r\n    const canLeave = beforeLeaveHook ? await beforeLeaveHook() : true;\r\n    if (canLeave === false || typeof canLeave === 'object') {\r\n      return canLeave;\r\n    }\r\n    const canEnter = beforeEnterHook ? await beforeEnterHook() : true;\r\n    if (canEnter === false || typeof canEnter === 'object') {\r\n      return canEnter;\r\n    }\r\n    return true;\r\n  }\r\n  async writeNavState(node, chain, direction, path, redirectFrom, index = 0, animation) {\r\n    if (this.busy) {\r\n      console.warn('[ion-router] router is busy, transition was cancelled');\r\n      return false;\r\n    }\r\n    this.busy = true;\r\n    // generate route event and emit will change\r\n    const routeEvent = this.routeChangeEvent(path, redirectFrom);\r\n    if (routeEvent) {\r\n      this.ionRouteWillChange.emit(routeEvent);\r\n    }\r\n    const changed = await writeNavState(node, chain, direction, index, false, animation);\r\n    this.busy = false;\r\n    if (changed) {\r\n      console.debug('[ion-router] route changed', path);\r\n    }\r\n    // emit did change\r\n    if (routeEvent) {\r\n      this.ionRouteDidChange.emit(routeEvent);\r\n    }\r\n    return changed;\r\n  }\r\n  setPath(path, direction, queryString) {\r\n    this.state++;\r\n    writePath(window.history, this.root, this.useHash, path, direction, this.state, queryString);\r\n  }\r\n  getPath() {\r\n    return readPath(window.location, this.root, this.useHash);\r\n  }\r\n  routeChangeEvent(path, redirectFromPath) {\r\n    const from = this.previousPath;\r\n    const to = generatePath(path);\r\n    this.previousPath = to;\r\n    if (to === from) {\r\n      return null;\r\n    }\r\n    const redirectedFrom = redirectFromPath ? generatePath(redirectFromPath) : null;\r\n    return {\r\n      from,\r\n      redirectedFrom,\r\n      to,\r\n    };\r\n  }\r\n  get el() { return getElement(this); }\r\n};\r\n\r\nconst routerLinkCss = \":host{--background:transparent;--color:var(--ion-color-primary, #3880ff);background:var(--background);color:var(--color)}:host(.ion-color){color:var(--ion-color-base)}a{font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit}\";\r\n\r\nconst RouterLink = class {\r\n  constructor(hostRef) {\r\n    registerInstance(this, hostRef);\r\n    /**\r\n     * When using a router, it specifies the transition direction when navigating to\r\n     * another page using `href`.\r\n     */\r\n    this.routerDirection = 'forward';\r\n    this.onClick = (ev) => {\r\n      openURL(this.href, ev, this.routerDirection, this.routerAnimation);\r\n    };\r\n  }\r\n  render() {\r\n    const mode = getIonMode(this);\r\n    const attrs = {\r\n      href: this.href,\r\n      rel: this.rel,\r\n      target: this.target\r\n    };\r\n    return (h(Host, { onClick: this.onClick, class: createColorClasses(this.color, {\r\n        [mode]: true,\r\n        'ion-activatable': true\r\n      }) }, h(\"a\", Object.assign({}, attrs), h(\"slot\", null))));\r\n  }\r\n};\r\nRouterLink.style = routerLinkCss;\r\n\r\nexport { Route as ion_route, RouteRedirect as ion_route_redirect, Router as ion_router, RouterLink as ion_router_link };\r\n"]}